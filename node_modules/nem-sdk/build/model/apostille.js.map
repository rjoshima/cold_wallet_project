{"version":3,"sources":["../../src/model/apostille.js"],"names":["hashing","name","signedVersion","version","hashFileData","data","isPrivate","checksum","MD5","SHA1","SHA256","SHA3","outputLength","create","common","fileName","fileContent","tags","isMultisig","multisigAccount","network","dedicatedAccount","apostilleHash","kp","fixPrivateKey","privateKey","generateAccount","hash","substring","dataHash","sign","toString","address","apostille","toUpperCase","replace","transaction","messageType","transactionEntity","prepare","verify","apostilleTransaction","type","otherTrans","message","payload","hashingByte","fileHash","retrieveHash","isSigned","verifySignature","signer","hashingVersionBytes","enc","Hex","array","Object","keys","i","length","signedFilename","dedicatedAccountPrivateKey","dedicatedAccountKeyPair","toAddress","publicKey","module","exports"],"mappings":"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","file":"apostille.js","sourcesContent":["import CryptoJS from 'crypto-js';\nimport Helpers from '../utils/helpers';\nimport Convert from '../utils/convert';\nimport KeyPair from '../crypto/keyPair';\nimport Address from '../model/address';\nimport Sinks from '../model/sinks';\nimport modelObjects from '../model/objects';\nimport Transactions from '../model/transactions';\n\n/**\n * Apostille hashing methods with version bytes\n *\n * @type {object}\n */\nconst hashing = {\n\t\"MD5\": {\n\t    name: \"MD5\",\n\t    signedVersion: \"81\",\n\t    version: \"01\"\n\t},\n\t\"SHA1\": {\n\t    name: \"SHA1\",\n\t    signedVersion: \"82\",\n\t    version: \"02\"\n\t},\n\t\"SHA256\" : {\n\t    name: \"SHA256\",\n\t    signedVersion: \"83\",\n\t    version: \"03\"\n\t},\n\t\"SHA3-256\": {\n\t    name: \"SHA3-256\",\n\t    signedVersion: \"88\",\n\t    version: \"08\"\n\t},\n\t\"SHA3-512\": {\n\t    name: \"SHA3-512\",\n\t    signedVersion: \"89\",\n\t    version: \"09\"\n\t}\n}\n\n/**\n * Hash the file content depending of hashing\n *\n * @param {wordArray} data - File content\n * @param {object} hashing - The chosen hashing object\n * @param {boolean} isPrivate - True if apostille is private, false otherwise\n *\n * @return {string} - The file hash with checksum\n */\nlet hashFileData = function(data, hashing, isPrivate) {\n    // Full checksum is 0xFE (added automatically if hex txes) + 0x4E + 0x54 + 0x59 + hashing version byte\n    let checksum;\n    // Append byte to checksum\n    if (isPrivate) {\n        checksum = \"4e5459\" + hashing.signedVersion;\n    } else {\n        checksum = \"4e5459\" + hashing.version;\n    }\n    // Build the apostille hash\n    if (hashing.name === \"MD5\") {\n        return checksum + CryptoJS.MD5(data);\n    } else if (hashing.name === \"SHA1\") {\n        return checksum + CryptoJS.SHA1(data);\n    } else if (hashing.name === \"SHA256\") {\n        return checksum + CryptoJS.SHA256(data);\n    } else if (hashing.name === \"SHA3-256\") {\n        return checksum + CryptoJS.SHA3(data, {\n            outputLength: 256\n        });\n    } else {\n        return checksum + CryptoJS.SHA3(data, {\n            outputLength: 512\n        });\n    }\n};\n\n/**\n * Create an apostille object\n *\n * @param {object} common - A common object\n * @param {string} fileName - The file name (with extension)\n * @param {wordArray} fileContent - The file content\n * @param {string} tags - The apostille tags\n * @param {object} hashing - An hashing object\n * @param {boolean} isMultisig - True if transaction is multisig, false otherwise\n * @param {object} multisigAccount - An [AccountInfo]{@link https://bob.nem.ninja/docs/#accountInfo} object\n * @param {boolean} isPrivate - True if apostille is private / transferable / updateable, false if public\n * @param {number} network - A network id\n *\n * @return {object} - An apostille object containing apostille data and the prepared transaction ready to be sent\n */\nlet create = function(common, fileName, fileContent, tags, hashing, isMultisig, multisigAccount, isPrivate, network) {\n\tlet dedicatedAccount = {};\n\tlet apostilleHash;\n\t//\n\tif (isPrivate) {\n        // Create user keypair\n        let kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));\n        // Create the dedicated account\n        dedicatedAccount = generateAccount(common, fileName, network);\n        // Create hash from file content and selected hashing\n        let hash = hashFileData(fileContent, hashing, isPrivate);\n        // Get checksum\n        let checksum = hash.substring(0, 8);\n        // Get hash without checksum\n        let dataHash = hash.substring(8);\n        // Set checksum + signed hash as message\n        apostilleHash = checksum + kp.sign(dataHash).toString();\n    } else {\n        // Use sink account\n        dedicatedAccount.address = Sinks.apostille[network].toUpperCase().replace(/-/g, '');\n        // Set recipient private key\n        dedicatedAccount.privateKey = \"None (public sink)\";\n        // No signing we just put the hash in message\n        apostilleHash = hashFileData(fileContent, hashing, isPrivate);\n\t}\n\n\t// Create transfer transaction object\n\tlet transaction = modelObjects.create(\"transferTransaction\")(dedicatedAccount.address, 0, apostilleHash);\n    // Multisig\n    transaction.isMultisig = isMultisig;\n    transaction.multisigAccount = multisigAccount;\n    // Set message type to hexadecimal\n    transaction.messageType = 0;\n\t// Prepare the transfer transaction object\n\tlet transactionEntity = Transactions.prepare(\"transferTransaction\")(common, transaction, network);\n\n\treturn {\n\t\t\"data\": {\n\t\t\t\"file\": {\n\t\t\t\t\"name\": fileName,\n\t\t\t\t\"hash\": apostilleHash.substring(8),\n\t\t\t\t\"content\": fileContent\n\t\t\t},\n\t\t\t\"hash\": \"fe\" + apostilleHash,\n\t\t\t\"checksum\": \"fe\" + apostilleHash.substring(0, 8),\n\t\t\t\"dedicatedAccount\": {\n\t\t\t\t\"address\": dedicatedAccount.address,\n\t\t\t\t\"privateKey\": dedicatedAccount.privateKey\n\t\t\t},\n\t\t\t\"tags\": tags\n\t\t},\n\t\t\"transaction\": transactionEntity\n\t}\n}\n\n/**\n * Verify an apostille\n *\n * @param {wordArray} fileContent - The file content\n * @param {object} apostilleTransaction - The transaction object for the apostille\n *\n * @return {boolean} - True if valid, false otherwise\n */\nlet verify = function(fileContent, apostilleTransaction) {\n    let apostilleHash;\n    if(apostilleTransaction.type === 4100) {\n        apostilleHash = apostilleTransaction.otherTrans.message.payload;\n    } else {\n        apostilleHash = apostilleTransaction.message.payload;\n    }\n\t// Get the checksum\n\tlet checksum = apostilleHash.substring(0, 10);\n\t// Get the hashing byte\n\tlet hashingByte = checksum.substring(8);\n\t// Retrieve the hashing method using the checksum in message and hash the file accordingly\n\tlet fileHash = retrieveHash(apostilleHash, fileContent);\n\t// Check if apostille is signed\n\tif(isSigned(hashingByte)) {\n\t\t// Verify signature\n\t\treturn KeyPair.verifySignature(apostilleTransaction.signer, fileHash, apostilleHash.substring(10));\n\t} else {\n\t\t// Check if hashed file match hash in transaction (without checksum)\n\t\treturn fileHash === apostilleHash.substring(10);\n\t}\n}\n\n\n/**\n * Hash a file according to version byte in checksum\n *\n * @param {string} apostilleHash - The hash contained in the apostille transaction\n * @param {wordArray} fileContent - The file content\n *\n * @return {string} - The file content hashed with correct hashing method\n */\nlet retrieveHash = function(apostilleHash, fileContent) {\n\t// Get checksum\n\tlet checksum = apostilleHash.substring(0, 10)\n    // Get the version byte\n    let hashingVersionBytes = checksum.substring(8);\n    // Hash depending of version byte\n    if (hashingVersionBytes === \"01\" || hashingVersionBytes === \"81\") {\n        return CryptoJS.MD5(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"02\" || hashingVersionBytes === \"82\") {\n        return CryptoJS.SHA1(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"03\" || hashingVersionBytes === \"83\") {\n\t\treturn CryptoJS.SHA256(fileContent).toString(CryptoJS.enc.Hex);\n    } else if (hashingVersionBytes === \"08\" || hashingVersionBytes === \"88\") {\n        return CryptoJS.SHA3(fileContent, { outputLength: 256 }).toString(CryptoJS.enc.Hex);\n    } else {\n        return CryptoJS.SHA3(fileContent, { outputLength: 512 }).toString(CryptoJS.enc.Hex);\n    }\n}\n\n/**\n * Check if an apostille is signed\n *\n * @param {string} hashingByte - An hashing version byte\n *\n * @return {boolean} - True if signed, false otherwise\n */\nlet isSigned = function(hashingByte) {\n\tlet array = Object.keys(hashing);\n    for (let i = 0; array.length > i; i++) {\n        if (hashing[array[i]].signedVersion === hashingByte) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Generate the dedicated account for a file. It will always generate the same private key for a given file name and private key\n *\n * @param {object} common - A common object\n * @param {string} fileName - The file name (with extension)\n * @param {number} network - A network id\n *\n * @return {object} - An object containing address and private key of the dedicated account\n */\nlet generateAccount = function(common, fileName, network) {\n\t// Create user keypair\n\tlet kp = KeyPair.create(Helpers.fixPrivateKey(common.privateKey));\n    // Create recipient account from signed sha256 hash of new filename\n    let signedFilename = kp.sign(CryptoJS.SHA256(fileName).toString(CryptoJS.enc.Hex)).toString();\n    // Truncate signed file name to get a 32 bytes private key\n    let dedicatedAccountPrivateKey = Helpers.fixPrivateKey(signedFilename);\n    // Create dedicated account key pair\n    let dedicatedAccountKeyPair = KeyPair.create(dedicatedAccountPrivateKey);\n    return {\n    \t\"address\":  Address.toAddress(dedicatedAccountKeyPair.publicKey.toString(), network),\n    \t\"privateKey\": dedicatedAccountPrivateKey\n    }\n}\n\nmodule.exports = {\n    create,\n    generateAccount,\n    hashing,\n    verify,\n    isSigned\n}\n"]}