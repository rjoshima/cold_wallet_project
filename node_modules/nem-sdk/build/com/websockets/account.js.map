{"version":3,"sources":["../../../src/com/websockets/account.js"],"names":["checkReadyState","connector","self","socket","readyState","OPEN","requestAccountData","address","timeoutHandle","setTimeout","requestData","_address","undefined","replace","toUpperCase","stompClient","send","requestRecentTransactions","requestMosaicDefinitions","requestMosaics","requestNamespaces","subscribeAccountData","callback","subscribe","data","JSON","parse","body","subscribeRecentTransactions","subscribeUnconfirmedTransactions","subscribeConfirmedTransactions","subscribeMosaicDefinitions","subscribeMosaics","subscribeNamespaces","module","exports","requests","transactions","recent","mosaics","owned","definitions","namespaces","confirmed","unconfirmed"],"mappings":";;AAAA;;AACA;;;;;;AAEA;;;;;;;AAOA,IAAIA,kBAAkB,SAAlBA,eAAkB,CAASC,SAAT,EAAoB;AACtC,QAAIC,OAAOD,SAAX;AACA,QAAI,iBAAgBC,KAAKC,MAAL,CAAYC,UAAZ,KAA2B,eAAcC,IAAzD,GAAgEH,KAAKC,MAAL,CAAYC,UAAZ,KAA2B,uBAAWC,IAA1G,EAAgH;AAC5G,eAAO,KAAP;AACH;AACD,WAAO,IAAP;AACH,CAND;;AAQA;;;;;;;;;AASA,IAAIC,qBAAqB,SAArBA,kBAAqB,CAASL,SAAT,EAAoBM,OAApB,EAA6B;AAClD,QAAIL,OAAOD,SAAX;AACA;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7BC,aAAKM,aAAL,GAAqBC,WAAW,YAAW;AACvCC,wBAAYT,SAAZ,EAAuBM,OAAvB;AACH,SAFoB,EAElB,GAFkB,CAArB;AAGH,KAJD,MAIO;AACH;AACA,YAAII,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,aAAKa,WAAL,CAAiBC,IAAjB,CAAsB,oBAAtB,EAA4C,EAA5C,EAAgD,iBAAiBL,QAAjB,GAA4B,IAA5E;AACH;AACJ,CAZD;;AAcA;;;;;;;;;AASA,IAAIM,4BAA4B,SAA5BA,yBAA4B,CAAShB,SAAT,EAAoBM,OAApB,EAA6B;AAC3D,QAAIL,OAAOD,SAAX;AACE;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7BC,aAAKM,aAAL,GAAqBC,WAAW,YAAW;AACvCQ,sCAA0BhB,SAA1B,EAAqCM,OAArC;AACH,SAFoB,EAElB,GAFkB,CAArB;AAGH,KAJD,MAIO;AACH;AACA,YAAII,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,aAAKa,WAAL,CAAiBC,IAAjB,CAAsB,8BAAtB,EAAsD,EAAtD,EAA0D,iBAAiBL,QAAjB,GAA4B,IAAtF;AACH;AACJ,CAZD;;AAcA;;;;;;;;;AASA,IAAIO,2BAA2B,SAA3BA,wBAA2B,CAASjB,SAAT,EAAoBM,OAApB,EAA6B;AACvD,QAAIL,OAAOD,SAAX;AACD;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7BC,aAAKM,aAAL,GAAqBC,WAAW,YAAW;AACvCQ,sCAA0BhB,SAA1B,EAAqCM,OAArC;AACH,SAFoB,EAElB,GAFkB,CAArB;AAGH,KAJD,MAIO;AACH;AACA,YAAII,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,aAAKa,WAAL,CAAiBC,IAAjB,CAAsB,wCAAtB,EAAgE,EAAhE,EAAoE,iBAAiBL,QAAjB,GAA4B,IAAhG;AACH;AACJ,CAZD;;AAcA;;;;;;;;;AASA,IAAIQ,iBAAiB,SAAjBA,cAAiB,CAASlB,SAAT,EAAoBM,OAApB,EAA6B;AAC7C,QAAIL,OAAOD,SAAX;AACD;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7BC,aAAKM,aAAL,GAAqBC,WAAW,YAAW;AACvCQ,sCAA0BhB,SAA1B,EAAqCM,OAArC;AACH,SAFoB,EAElB,GAFkB,CAArB;AAGH,KAJD,MAIO;AACH;AACA,YAAII,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,aAAKa,WAAL,CAAiBC,IAAjB,CAAsB,6BAAtB,EAAqD,EAArD,EAAyD,iBAAiBL,QAAjB,GAA4B,IAArF;AACH;AACJ,CAZD;;AAcA;;;;;;;;;AASA,IAAIS,oBAAoB,SAApBA,iBAAoB,CAASnB,SAAT,EAAoBM,OAApB,EAA6B;AAChD,QAAIL,OAAOD,SAAX;AACD;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7BC,aAAKM,aAAL,GAAqBC,WAAW,YAAW;AACvCQ,sCAA0BhB,SAA1B,EAAqCM,OAArC;AACH,SAFoB,EAElB,GAFkB,CAArB;AAGH,KAJD,MAIO;AACH;AACA,YAAII,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,aAAKa,WAAL,CAAiBC,IAAjB,CAAsB,gCAAtB,EAAwD,EAAxD,EAA4D,iBAAiBL,QAAjB,GAA4B,IAAxF;AACH;AACJ,CAZD;;AAcA;;;;;;;;;AASA,IAAIU,uBAAuB,SAAvBA,oBAAuB,CAASpB,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AACjE,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC1B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACHL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,cAAcZ,QAAzC,EAAmD,UAASa,IAAT,EAAe;AAC3DF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT;AACH,KAFJ;AAGA,CAVD;;AAYA;;;;;;;;;AASA,IAAIC,8BAA8B,SAA9BA,2BAA8B,CAAS3B,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AACxE,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC1B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACHL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,yBAAyBZ,QAApD,EAA8D,UAASa,IAAT,EAAe;AACtEF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT;AACH,KAFJ;AAGA,CAVD;;AAYA;;;;;;;;;AASA,IAAIE,mCAAmC,SAAnCA,gCAAmC,CAAS5B,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AAC1E,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,kBAAkBZ,QAA7C,EAAuD,UAASa,IAAT,EAAe;AAClEF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT;AACH,KAFD;AAGH,CAVD;;AAYA;;;;;;;;;AASA,IAAIG,iCAAiC,SAAjCA,8BAAiC,CAAS7B,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AACxE,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,mBAAmBZ,QAA9C,EAAwD,UAASa,IAAT,EAAe;AACnEF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT;AACH,KAFD;AAGH,CAVD;;AAYA;;;;;;;;;AASA,IAAII,6BAA6B,SAA7BA,0BAA6B,CAAS9B,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AACpE,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,sCAAsCZ,QAAjE,EAA2E,UAASa,IAAT,EAAe;AACtFF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT;AACH,KAFD;AAGH,CAVD;;AAYA;;;;;;;;;AASA,IAAIK,mBAAmB,SAAnBA,gBAAmB,CAAS/B,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AAC1D,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,2BAA2BZ,QAAtD,EAAgE,UAASa,IAAT,EAAe;AAC3EF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT,EAAgChB,QAAhC;AACH,KAFD;AAGH,CAVD;;AAYA;;;;;;;;;AASA,IAAIsB,sBAAsB,SAAtBA,mBAAsB,CAAShC,SAAT,EAAoBqB,QAApB,EAA8Bf,OAA9B,EAAuC;AAC7D,QAAIL,OAAOD,SAAX;AACA,QAAI,CAACD,gBAAgBC,SAAhB,CAAL,EAAiC;AAC7B,eAAO,KAAP;AACH;AACD;AACA,QAAIU,WAAWC,cAAcL,OAAd,GAAwBA,QAAQM,OAAR,CAAgB,IAAhB,EAAsB,EAAtB,EAA0BC,WAA1B,EAAxB,GAAkEZ,KAAKK,OAAtF;AACAL,SAAKa,WAAL,CAAiBQ,SAAjB,CAA2B,8BAA8BZ,QAAzD,EAAmE,UAASa,IAAT,EAAe;AAC9EF,iBAASG,KAAKC,KAAL,CAAWF,KAAKG,IAAhB,CAAT,EAAgChB,QAAhC;AACH,KAFD;AAGH,CAVD;;AAYAuB,OAAOC,OAAP,GAAiB;AAChBC,cAAU;AACTZ,cAAMlB,kBADG;AAET+B,sBAAc;AACbC,oBAAQrB;AADK,SAFL;AAKHsB,iBAAS;AACLC,mBAAOrB,cADF;AAELsB,yBAAavB;AAFR,SALN;AASHwB,oBAAY;AACRF,mBAAOpB;AADC;AATT,KADM;AAchBG,eAAW;AACVC,cAAMH,oBADI;AAEVgB,sBAAc;AACbC,oBAAQV,2BADK;AAEJe,uBAAWb,8BAFP;AAGbc,yBAAaf;AAHA,SAFJ;AAOJU,iBAAS;AACLC,mBAAOR,gBADF;AAELS,yBAAaV;AAFR,SAPL;AAWJW,oBAAY;AACRF,mBAAOP;AADC;AAXR;AAdK,CAAjB","file":"account.js","sourcesContent":["import { SockJS as SockJSBrowser } from '../../external/sockjs-0.3.4';\nimport SockJSNode from 'sockjs-client';\n\n/**\n * Check if socket is open\n *\n * @param {object} connector - A connector object\n *\n * @return {boolean} - True if open, false otherwise\n */\nlet checkReadyState = function(connector) {\n    var self = connector;\n    if (SockJSBrowser ? self.socket.readyState !== SockJSBrowser.OPEN : self.socket.readyState !== SockJSNode.OPEN) {\n        return false;\n    } \n    return true;\n}\n\n/**\n * Request the account data of the address in the given connector\n * You can optionally use an address directly to request data for a specific account\n *\n * @param {object} connector - A connector object\n * @param {string} address - A NEM account address (optional)\n *\n * @return the response in the subscription callback\n */\nlet requestAccountData = function(connector, address) {\n    var self = connector;\n    // If not ready, wait a bit more...\n    if (!checkReadyState(connector)) {\n        self.timeoutHandle = setTimeout(function() {\n            requestData(connector, address);\n        }, 100);\n    } else {\n        // Use address if provided\n        let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n        self.stompClient.send(\"/w/api/account/get\", {}, \"{'account':'\" + _address + \"'}\");\n    }\n}\n\n/**\n * Request the recent transactions of the address in the given connector\n * You can optionally use an address directly to request data for a specific account\n *\n * @param {object} connector - A connector object\n * @param {string} address - A NEM account address (optional)\n *\n * @return the response in the subscription callback\n */\nlet requestRecentTransactions = function(connector, address) {\n\t var self = connector;\n    // If not ready, wait a bit more...\n    if (!checkReadyState(connector)) {\n        self.timeoutHandle = setTimeout(function() {\n            requestRecentTransactions(connector, address);\n        }, 100);\n    } else {\n        // Use address if provided\n        let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n        self.stompClient.send(\"/w/api/account/transfers/all\", {}, \"{'account':'\" + _address + \"'}\");\n    }\n}\n\n/**\n * Request the owned mosaic definitions of the address in the given connector\n * You can optionally use an address directly to request data for a specific account\n *\n * @param {object} connector - A connector object\n * @param {string} address - A NEM account address (optional)\n *\n * @return the response in the subscription callback\n */\nlet requestMosaicDefinitions = function(connector, address) {\n     var self = connector;\n    // If not ready, wait a bit more...\n    if (!checkReadyState(connector)) {\n        self.timeoutHandle = setTimeout(function() {\n            requestRecentTransactions(connector, address);\n        }, 100);\n    } else {\n        // Use address if provided\n        let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n        self.stompClient.send(\"/w/api/account/mosaic/owned/definition\", {}, \"{'account':'\" + _address + \"'}\");\n    }\n}\n\n/**\n * Request the owned mosaics of the address in the given connector\n * You can optionally use an address directly to request data for a specific account\n *\n * @param {object} connector - A connector object\n * @param {string} address - A NEM account address (optional)\n *\n * @return the response in the subscription callback\n */\nlet requestMosaics = function(connector, address) {\n     var self = connector;\n    // If not ready, wait a bit more...\n    if (!checkReadyState(connector)) {\n        self.timeoutHandle = setTimeout(function() {\n            requestRecentTransactions(connector, address);\n        }, 100);\n    } else {\n        // Use address if provided\n        let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n        self.stompClient.send(\"/w/api/account/mosaic/owned\", {}, \"{'account':'\" + _address + \"'}\");\n    }\n}\n\n/**\n * Request the owned namespaces of the address in the given connector\n * You can optionally use an address directly to request data for a specific account\n *\n * @param {object} connector - A connector object\n * @param {string} address - A NEM account address (optional)\n *\n * @return the response in the subscription callback\n */\nlet requestNamespaces = function(connector, address) {\n     var self = connector;\n    // If not ready, wait a bit more...\n    if (!checkReadyState(connector)) {\n        self.timeoutHandle = setTimeout(function() {\n            requestRecentTransactions(connector, address);\n        }, 100);\n    } else {\n        // Use address if provided\n        let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n        self.stompClient.send(\"/w/api/account/namespace/owned\", {}, \"{'account':'\" + _address + \"'}\");\n    }\n}\n\n/**\n * Subscribe to the account data channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeAccountData = function(connector, callback, address) {\n\tvar self = connector;\n\tif (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n\tself.stompClient.subscribe('/account/' + _address, function(data) {\n        callback(JSON.parse(data.body));\n    });\n}\n\n/**\n * Subscribe to the recent transactions channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeRecentTransactions = function(connector, callback, address) {\n\tvar self = connector;\n\tif (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n\tself.stompClient.subscribe('/recenttransactions/' + _address, function(data) {\n        callback(JSON.parse(data.body));\n    }); \n}\n\n/**\n * Subscribe to the unconfirmed transactions channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeUnconfirmedTransactions = function(connector, callback, address) {\n    var self = connector;\n    if (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n    self.stompClient.subscribe('/unconfirmed/' + _address, function(data) {\n        callback(JSON.parse(data.body));\n    });\n}\n\n/**\n * Subscribe to the confirmed transactions channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeConfirmedTransactions = function(connector, callback, address) {\n    var self = connector;\n    if (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n    self.stompClient.subscribe('/transactions/' + _address, function(data) {\n        callback(JSON.parse(data.body));\n    });\n}\n\n/**\n * Subscribe to the mosaic definitions channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeMosaicDefinitions = function(connector, callback, address) {\n    var self = connector;\n    if (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n    self.stompClient.subscribe('/account/mosaic/owned/definition/' + _address, function(data) {\n        callback(JSON.parse(data.body));\n    });\n}\n\n/**\n * Subscribe to the owned mosaics channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeMosaics = function(connector, callback, address) {\n    var self = connector;\n    if (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n    self.stompClient.subscribe('/account/mosaic/owned/' + _address, function(data) {\n        callback(JSON.parse(data.body), _address);\n    });\n}\n\n/**\n * Subscribe to the owned namespaces channel for the address in the given connector \n *\n * @param {object} connector - A connector object\n * @param {function} callback - A callback function where data will be received\n * @param {string} address - A NEM account address (optional)\n *\n * @return the received data in the callback\n */\nlet subscribeNamespaces = function(connector, callback, address) {\n    var self = connector;\n    if (!checkReadyState(connector)) {\n        return false;\n    }\n    // Use address if provided\n    let _address = undefined !== address ? address.replace(/-/g, \"\").toUpperCase() : self.address;\n    self.stompClient.subscribe('/account/namespace/owned/' + _address, function(data) {\n        callback(JSON.parse(data.body), _address);\n    });\n}\n\nmodule.exports = {\n\trequests: {\n\t\tdata: requestAccountData,\n\t\ttransactions: {\n\t\t\trecent: requestRecentTransactions\n\t\t},\n        mosaics: {\n            owned: requestMosaics,\n            definitions: requestMosaicDefinitions\n        },\n        namespaces: {\n            owned: requestNamespaces\n        }\n\t},\n\tsubscribe: {\n\t\tdata: subscribeAccountData,\n\t\ttransactions: {\n\t\t\trecent: subscribeRecentTransactions,\n            confirmed: subscribeConfirmedTransactions,\n\t\t\tunconfirmed: subscribeUnconfirmedTransactions\n\t\t},\n        mosaics: {\n            owned: subscribeMosaics,\n            definitions: subscribeMosaicDefinitions\n        },\n        namespaces: {\n            owned: subscribeNamespaces\n        } \n\t}\n}"]}